import tkinter as tk
from tkinter import messagebox, font  #отображения сообщений и работы со шрифтами
import random  #random для генерации случайных чисел

class TicTacToeApp:
    def __init__(self, master):
        # Конструктор класса, который инициализирует основные параметры игры
        self.master = master  # Главное окно приложения
        self.master.title("Крестики-нолики 7x7")  # Заголовок окна
        self.master.configure(bg='#f0f0f0')  # Цвет фона окна
        self.master.state('zoomed')  # Развертывание окна на весь экран
        self.player_symbols = ['X', 'O']  # Массив символов игроков
        random.shuffle(self.player_symbols)  # Перемешивание символов для случайного выбора первого игрока
        self.current_player = 0  # Индекс текущего игрока (0 или 1)
        self.board = [['' for _ in range(7)] for _ in range(7)]  # Инициализация игрового поля размером 7x7
        self.buttons = [[None for _ in range(7)] for _ in range(7)]  # Инициализация массива кнопок для поля
        self.last_player_move = (None, None)  # Последний ход игрока (изначально не установлен)
        self.create_menu()  # Вызов метода для создания начального меню

    def create_menu(self):
        # Метод для создания начального меню игры
        self.clear_window()  # Очистка содержимого главного окна
        menu_frame = tk.Frame(self.master, bg='#f0f0f0', padx=20, pady=20)  # Создание фрейма для кнопок меню
        menu_frame.pack(expand=True)  # Размещение фрейма в главном окне

        #шрифта для кнопок
        button_font = font.Font(family='Helvetica', size=24, weight='bold')
        # Общие настройки для кнопок
        buttons_options = {'font': button_font, 'bg': '#a7c7e7', 'fg': 'white', 'padx': 10, 'pady': 5}
        # Создание кнопок и привязка к ним действий
        tk.Button(menu_frame, text="Играть с другом", **buttons_options, command=lambda: self.setup_board('friend')).pack(fill=tk.BOTH, expand=True, pady=10)
        tk.Button(menu_frame, text="Играть с компьютером", **buttons_options, command=lambda: self.setup_board('computer')).pack(fill=tk.BOTH, expand=True, pady=10)
        tk.Button(menu_frame, text="Правила", **buttons_options, command=self.show_rules).pack(fill=tk.BOTH, expand=True, pady=10)
        tk.Button(menu_frame, text="Выход", **buttons_options, command=self.exit_app).pack(fill=tk.BOTH, expand=True, pady=10)
    def setup_board(self, mode):
        # Метод для настройки игрового поля после выбора режима игры
        self.clear_window()  # Очистка окна
        self.board = [['' for _ in range(7)] for _ in range(7)]  # Переинициализация игрового поля
        self.current_player = 0  # Сброс текущего игрока
        self.game_mode = mode  # Установка режима игры
        # Установка статусной строки внизу окна
        self.status_label = tk.Label(self.master, text='', font=('Arial', 20), bg='#f0f0f0', fg='black')
        self.status_label.grid(row=7, column=0, columnspan=7, sticky='ew')

        # Настройки кнопок игрового поля
        button_options = {'font': ('Arial', 20), 'width': 5, 'height': 2, 'bg': '#a7c7e7', 'fg': 'black'}
        for i in range(7):
            for j in range(7):
                btn = tk.Button(self.master, text='', **button_options,
                                command=lambda x=i, y=j: self.make_move(x, y))
                btn.grid(row=i, column=j, sticky='nsew', padx=5, pady=5)
                self.buttons[i][j] = btn  # Сохранение ссылки на кнопку в массиве

        # Настройка сетки окна для равномерного распределения пространства
        for i in range(7):
            self.master.grid_rowconfigure(i, weight=1)
            self.master.grid_columnconfigure(i, weight=1)
        self.master.grid_rowconfigure(7, weight=0)

        # Кнопка для возврата в меню
        tk.Button(self.master, text="Выйти в меню", font=('Arial', 12), bg='#a7c7e7', fg='black', command=self.create_menu).grid(row=8, column=0, columnspan=7, sticky='nsew', pady=10)

        self.update_status()  # Обновление статуса игры

    def make_move(self, x, y):
        # Метод для обработки хода игрока
        if self.board[x][y] == '':
            self.board[x][y] = self.player_symbols[self.current_player]  # Запись символа текущего игрока в выбранную ячейку
            self.buttons[x][y]['text'] = self.player_symbols[self.current_player]  # Отображение символа на кнопке
            self.buttons[x][y]['disabledforeground'] = 'black'
            self.buttons[x][y]['state'] = 'disabled'  # Деактивация кнопки
            self.last_player_move = (x, y)  # Запоминание последнего хода
            winning_line = self.check_win(x, y)  # Проверка на победу
            if winning_line:
                # Если есть выигрышная линия, подсветить её
                for wx, wy in winning_line:
                    self.buttons[wx][wy]['bg'] = 'light green'
                # Показать сообщение о победе
                if self.game_mode == 'computer':
                    if self.current_player == 1:
                        messagebox.showinfo("Победа!", "Компьютер победил!")
                    else:
                        messagebox.showinfo("Победа!", "Победил игрок!")
                else:
                    messagebox.showinfo("Победа!", f"Игрок {self.player_symbols[self.current_player]} выиграл!")
                self.create_menu()  # Возврат в меню
                return
            elif all(all(row) for row in self.board):
                # Проверка на ничью (если все клетки заполнены)
                messagebox.showinfo("Ничья", "Игра закончилась вничью!")
                self.create_menu()  # Возврат в меню
                return
            self.current_player = 1 - self.current_player  # Смена игрока
            self.update_status()  # Обновление статуса
            if self.game_mode == 'computer' and self.current_player == 1:
                self.master.after(500, self.computer_move)  # Вызов хода компьютера после задержки

    def check_win(self, x, y):
        # Проверка наличия выигрышной линии из четырех подряд идущих одинаковых символов
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]  # Возможные направления: горизонталь, вертикаль, две диагонали
        symbol = self.board[x][y]  # Символ на последней занятой позиции
        for dx, dy in directions:
            line = [(x, y)]  # Начальная точка линии
            for d in [1, -1]:  # Проверка в обе стороны от начальной точки
                nx, ny = x, y
                while True:
                    nx += dx * d  # Смещение вдоль линии
                    ny += dy * d
                    if 0 <= nx < 7 and 0 <= ny < 7 and self.board[nx][ny] == symbol:
                        line.append((nx, ny))  # Добавление точки к линии
                    else:
                        break
            if len(line) >= 4:  # Если длина линии достигла четырех, возвращаем её
                return line
        return None

    def computer_move(self):
        # Метод для автоматического хода компьютера
        for check_win in [True, False]:  # Сначала пытаемся выиграть, затем блокировать ход противника
            for x in range(7):
                for y in range(7):
                    if self.board[x][y] == '':
                        self.board[x][y] = self.player_symbols[1] if check_win else self.player_symbols[0]
                        if self.check_win(x, y):
                            self.board[x][y] = ''
                            self.make_move(x, y)
                            return
                        self.board[x][y] = ''
        empty_cells = [(x, y) for x in range(7) for y in range(7) if self.board[x][y] == '']  # Список пустых клеток
        if empty_cells:
            move = random.choice(empty_cells)  # Выбор случайной клетки
            self.make_move(*move)  # Совершение хода

    def update_status(self):
        # Обновление информационного сообщения о текущем состоянии игры
        if self.game_mode == 'computer':
            if self.current_player == 0:
                status_text = f"Ваш ход: {self.player_symbols[self.current_player]}"
            else:
                status_text = "Ход компьютера"
        else:
            status_text = f"Ход игрока: {self.player_symbols[self.current_player]}"
        self.status_label['text'] = status_text

    def show_rules(self):
        # Отображение правил игры
        messagebox.showinfo("Правила", "Игроки по очереди ставят на свободные клетки поля 7x7 свои символы (X или O). Выигрывает тот, кто первым выстроит 4 своих символа в ряд по вертикали, горизонтали или диагонали.")

    def clear_window(self):
        # Очистка всех элементов в главном окне
        for widget in self.master.winfo_children():
            widget.destroy()

    def exit_app(self):
        # Закрытие приложения
        self.master.quit()

if __name__ == "__main__":
    root = tk.Tk()  # Создание элемента интерфейса
    app = TicTacToeApp(root)  # Создание объекта приложения
    root.mainloop()  # Запуск цикла обработки событий
